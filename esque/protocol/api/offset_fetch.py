# FIXME autogenerated module, check for errors!
from typing import Dict, List

from dataclasses import dataclass

from esque.protocol.api.base import ApiKey, RequestData, ResponseData
from esque.protocol.serializers import (
    ArraySerializer,
    BaseSerializer,
    DummySerializer,
    NamedTupleSerializer,
    Schema,
    int16Serializer,
    int32Serializer,
    int64Serializer,
    nullableStringSerializer,
    stringSerializer,
)


@dataclass
class Partitions:
    # Topic partition id
    partition: "int"  # INT32


@dataclass
class Topics:
    # Name of topic
    topic: "str"  # STRING

    # Partitions to fetch offsets.
    partitions: List["Partitions"]


@dataclass
class OffsetFetchRequestData(RequestData):
    # The unique group identifier
    group_id: "str"  # STRING

    # Topics to fetch offsets. If the topic array is null fetch offsets for all topics.
    topics: List["Topics"]

    @staticmethod
    def api_key() -> int:
        return ApiKey.OFFSET_FETCH  # == 9


@dataclass
class PartitionResponses:
    # Topic partition id
    partition: "int"  # INT32

    # Message offset to be committed
    offset: "int"  # INT64

    # The leader epoch, if provided is derived from the last consumed record. This is used by the consumer
    # to check for log truncation and to ensure partition metadata is up to date following a group
    # rebalance.
    leader_epoch: "int"  # INT32

    # Any associated metadata the client wants to keep.
    metadata: "Optional[str]"  # NULLABLE_STRING

    # Response error code
    error_code: "int"  # INT16


@dataclass
class Responses:
    # Name of topic
    topic: "str"  # STRING

    # Responses by partition for fetched offsets
    partition_responses: List["PartitionResponses"]


@dataclass
class OffsetFetchResponseData(ResponseData):
    # Duration in milliseconds for which the request was throttled due to quota violation (Zero if the
    # request did not violate any quota)
    throttle_time_ms: "int"  # INT32

    # Responses by topic for fetched offsets
    responses: List["Responses"]

    # Response error code
    error_code: "int"  # INT16

    @staticmethod
    def api_key() -> int:
        return ApiKey.OFFSET_FETCH  # == 9


partitionsSchemas: Dict[int, Schema] = {
    0: [("partition", int32Serializer)],
    1: [("partition", int32Serializer)],
    2: [("partition", int32Serializer)],
    3: [("partition", int32Serializer)],
    4: [("partition", int32Serializer)],
    5: [("partition", int32Serializer)],
}


partitionsSerializers: Dict[int, BaseSerializer[Partitions]] = {
    version: NamedTupleSerializer(Partitions, schema) for version, schema in partitionsSchemas.items()
}


topicsSchemas: Dict[int, Schema] = {
    0: [("topic", stringSerializer), ("partitions", ArraySerializer(partitionsSerializers[0]))],
    1: [("topic", stringSerializer), ("partitions", ArraySerializer(partitionsSerializers[1]))],
    2: [("topic", stringSerializer), ("partitions", ArraySerializer(partitionsSerializers[2]))],
    3: [("topic", stringSerializer), ("partitions", ArraySerializer(partitionsSerializers[3]))],
    4: [("topic", stringSerializer), ("partitions", ArraySerializer(partitionsSerializers[4]))],
    5: [("topic", stringSerializer), ("partitions", ArraySerializer(partitionsSerializers[5]))],
}


topicsSerializers: Dict[int, BaseSerializer[Topics]] = {
    version: NamedTupleSerializer(Topics, schema) for version, schema in topicsSchemas.items()
}


offsetFetchRequestDataSchemas: Dict[int, Schema] = {
    0: [("group_id", stringSerializer), ("topics", ArraySerializer(topicsSerializers[0]))],
    1: [("group_id", stringSerializer), ("topics", ArraySerializer(topicsSerializers[1]))],
    2: [("group_id", stringSerializer), ("topics", ArraySerializer(topicsSerializers[2]))],
    3: [("group_id", stringSerializer), ("topics", ArraySerializer(topicsSerializers[3]))],
    4: [("group_id", stringSerializer), ("topics", ArraySerializer(topicsSerializers[4]))],
    5: [("group_id", stringSerializer), ("topics", ArraySerializer(topicsSerializers[5]))],
}


offsetFetchRequestDataSerializers: Dict[int, BaseSerializer[OffsetFetchRequestData]] = {
    version: NamedTupleSerializer(OffsetFetchRequestData, schema)
    for version, schema in offsetFetchRequestDataSchemas.items()
}


partitionResponsesSchemas: Dict[int, Schema] = {
    0: [
        ("partition", int32Serializer),
        ("offset", int64Serializer),
        ("metadata", nullableStringSerializer),
        ("error_code", int16Serializer),
        ("leader_epoch", DummySerializer(int())),
    ],
    1: [
        ("partition", int32Serializer),
        ("offset", int64Serializer),
        ("metadata", nullableStringSerializer),
        ("error_code", int16Serializer),
        ("leader_epoch", DummySerializer(int())),
    ],
    2: [
        ("partition", int32Serializer),
        ("offset", int64Serializer),
        ("metadata", nullableStringSerializer),
        ("error_code", int16Serializer),
        ("leader_epoch", DummySerializer(int())),
    ],
    3: [
        ("partition", int32Serializer),
        ("offset", int64Serializer),
        ("metadata", nullableStringSerializer),
        ("error_code", int16Serializer),
        ("leader_epoch", DummySerializer(int())),
    ],
    4: [
        ("partition", int32Serializer),
        ("offset", int64Serializer),
        ("metadata", nullableStringSerializer),
        ("error_code", int16Serializer),
        ("leader_epoch", DummySerializer(int())),
    ],
    5: [
        ("partition", int32Serializer),
        ("offset", int64Serializer),
        ("leader_epoch", int32Serializer),
        ("metadata", nullableStringSerializer),
        ("error_code", int16Serializer),
    ],
}


partitionResponsesSerializers: Dict[int, BaseSerializer[PartitionResponses]] = {
    version: NamedTupleSerializer(PartitionResponses, schema) for version, schema in partitionResponsesSchemas.items()
}


responsesSchemas: Dict[int, Schema] = {
    0: [("topic", stringSerializer), ("partition_responses", ArraySerializer(partitionResponsesSerializers[0]))],
    1: [("topic", stringSerializer), ("partition_responses", ArraySerializer(partitionResponsesSerializers[1]))],
    2: [("topic", stringSerializer), ("partition_responses", ArraySerializer(partitionResponsesSerializers[2]))],
    3: [("topic", stringSerializer), ("partition_responses", ArraySerializer(partitionResponsesSerializers[3]))],
    4: [("topic", stringSerializer), ("partition_responses", ArraySerializer(partitionResponsesSerializers[4]))],
    5: [("topic", stringSerializer), ("partition_responses", ArraySerializer(partitionResponsesSerializers[5]))],
}


responsesSerializers: Dict[int, BaseSerializer[Responses]] = {
    version: NamedTupleSerializer(Responses, schema) for version, schema in responsesSchemas.items()
}


offsetFetchResponseDataSchemas: Dict[int, Schema] = {
    0: [
        ("responses", ArraySerializer(responsesSerializers[0])),
        ("throttle_time_ms", DummySerializer(int())),
        ("error_code", DummySerializer(int())),
    ],
    1: [
        ("responses", ArraySerializer(responsesSerializers[1])),
        ("throttle_time_ms", DummySerializer(int())),
        ("error_code", DummySerializer(int())),
    ],
    2: [
        ("responses", ArraySerializer(responsesSerializers[2])),
        ("error_code", int16Serializer),
        ("throttle_time_ms", DummySerializer(int())),
    ],
    3: [
        ("throttle_time_ms", int32Serializer),
        ("responses", ArraySerializer(responsesSerializers[3])),
        ("error_code", int16Serializer),
    ],
    4: [
        ("throttle_time_ms", int32Serializer),
        ("responses", ArraySerializer(responsesSerializers[4])),
        ("error_code", int16Serializer),
    ],
    5: [
        ("throttle_time_ms", int32Serializer),
        ("responses", ArraySerializer(responsesSerializers[5])),
        ("error_code", int16Serializer),
    ],
}


offsetFetchResponseDataSerializers: Dict[int, BaseSerializer[OffsetFetchResponseData]] = {
    version: NamedTupleSerializer(OffsetFetchResponseData, schema)
    for version, schema in offsetFetchResponseDataSchemas.items()
}
